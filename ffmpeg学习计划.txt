
jni
1. 回调 java 对象方法 -- 注意 jm 对象获取 env 对象，因为 env对象只能在java 调用 jni 方法的线程用生效，所以不能保存，其他线程（如c++自己开辟的线程）想调用，则需要借 jm 来达到此目的。
2. 动态注册 native 方法。
3. 因为 C++ 声明静态对象的原因，如何一个播放器声明一个对象？而不是公用一个对象。？？有没有可能，java和native对象互通？ -- ijkplayer的jni层绝对有解答
	1. 自己的解决方案是，通过在 java对象保存一个 long 类型的数据，用于保存 C++对象的指针。 当创建 C++对象之后，通过反射，调用java对象的赋值方法，将对象指针转成long型，复制给java对象。然后如果在想调用 C++对象的方法时，就获取java层的指针，强转成 对象指针，然后用来使用。 针对这种方案。
4. 引用关系，Java 回收传给 jni 的对象， jni 如何阻止java gc 对该对象的回收，或者说，如何知道java 对象已经被回收？ 可以在 jni 创建引用，从而阻止 java gc回收，但是不应该由 jni 层来决定是否回收该对象，这是java 决定的才对，所以jni层应该 保存weakReference，通过 env->IsSameObject(ref, nullptr) 来判断引用是否已经为空，如果Java层已经回收了该对象，那么native层的弱引用就会被认为是空指针，就可以知道是否已经被 java 虚拟机回收，后续操作就不应该涉及该对象。
5. 对于C++创建的对象，因为它是不知道 上层java什么时候结果调用，所以应该由java层，主动 release 掉 C++创建的对象，避免 native 内存泄漏。所以，要让用户正确调用 api 来释放掉 C++ 对象。


opengl
1. opengl 的初始化流程 -- 搭配 EGL 使用，用EGL 共享 opengl 上下文。方便纹理传递
2. 渲染一张照片到屏幕 -- 将图片转成rgb纹理，设置纹理的数据，顶点着色器、片段着色器的使用。
3. 将 yuv 数据，转变成 rgb纹理，然后渲染到屏幕上。 -- yuv数据可以考虑用 ffmpeg 将视频的yuv数据独立出来。视频速度控制同步问题如何解决？

提升：
1. 在 2 中，在图片上层添加个水印。


ffmpeg：
1. 交叉编译 集成 ffmpeg
2. 交叉编译 集成 x264、aac 音视频编解码器
3. 交叉编译 librtmp 集成 推流模块。
4. 重要的结构体分析 -- 以至于知道 音视频信息在哪里，搞懂 ffmpeg 的操作


视频处理：
1. 用 ffmpeg 软解码 MP4文件，用于播放  -- 软解 -- 兼容所有版本
2. 用 MediaCodec 硬解码 mp4 文件，用于播放。	--硬解 4.3

提升：
1. 用 ffmpeg或 opengl 添加滤镜功能，做美颜？提亮度？

音频处理：
1. 用 opensl 播放pcm数据。 -- 渲染
2. 用 opensl 录制音频数据。-- 采集
3. 用 AudioTracker 录制音频数据。
4. 用 AudioTracker 播放pcm数据。

提升：
1. 同时播放多段pcm数据，就是混音播放，比如添加背景音乐。
2. 添加音量效果器，即把音频的声音大小调高。 -- 音频Filter


录制：
将录制的音频、视频信息，封装成MP4文件。

推流
将录制的音频、视频信息，muter 后，以rtmp形式推流到服务器

源码：
ijkplayer
1. 学习播放器的状态管理、配置参数
2. 动态编译，支持rtsp流