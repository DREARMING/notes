Replugin

一. 宿主模块 - host 的框架初始化
应用的 Application 在 attachBaseContext时，就会进入 Replugin 框架 的初始化过程，记住：不仅是宿主进程、如果存在常驻进程、插件进程，都会走这个初始化过程。
然后在 RepluginApplication 的attachBaseContext 方法中创建 一个 RepluginConfig 对象，然后调用 Replugin.attachBaseContext 方法，该方法就是整个Replugin框架初始化的入口
1. 首先调用 RePluginInternal.init(app) keep住 Application 的引用，暂时不清楚该类的作用
2. 调用 IPC.init(appContext) 方法，IPC类就只是一个工具类，记录当前进程一些基本信息：进程id、是否是常驻进程或者UI进程，包名
3. 调用 HostConfigHelper.init() 方法， 这个方法比较重要，这是在 HostConfigHelper类的静态块里面， 读取 由 gradle 生成的配置类的各个字段：RepluginHostConfig，
该配置类配置了 坑位的数量、常驻进程的名字、是否由常驻进程管理插件类、TaskAffinity 组数、是否使用 AppCompat 库 这些信息，对应了gradle host 插件的 repluginHostConfig 配置块
3. PluginStatusController.setAppContext(app) , 这是一个插件状态管理器，主要通过 preference 来保存异常插件的信息：比如禁用的插件

4. 调用 PMF.init(app) 方法，-- PMF 主要是一个代理类，方法都是由 Pmbase 实现的
	1. 初始化 PluginManager，调用evalPluginProcess 分析当前进程分析出是否是 常驻进程、UI进程、插件进程、进程Index，可以提供方法用来判断进程的有效性
	2. 构建 整个框架 的核心类 Pmbase， 在构造函数中，创建了 mClient:PluginProcessPer、mLocal:PluginCommImpl、mInternal:PluginLibraryInternalProxy 三个对象
	PluginProcessPer 是一个 binder 实现类，其原型是 IPluginClient.Stub, 它的作用就是借助 其成员变量 mACM来分配坑位，还可以解析出具体的坑位的 activity，借助Plugin的loader 就可以找到该 activity，并且借助Plugin的classloader加载。同时也可以把该 binder 对象传给常驻进程，这可以设计一个进程的存活监听
		1. 它具备一个 mACM:PluginContainers 的成员变量，并在构造函数中进行初始化。该类主要是处理坑位的，它持有整个程序的坑位，然后负责回收、分配、查询等工作，
		坑位的状态 是通过 ActivityState 类保存，该类持有：plugin、container（坑位全名）、state（坑位占用情况）、activity（占用坑位的目标activity）。 PluginContainer 有一个mStates的成员变量，它是一个map，key是坑位的具体名称，value是ActivityState，可以从这里轻松查询到 坑位的占据情况
		gradle分配的坑位策略是：
		1. 每种进程分配相同多的坑位 - 最多3个进程
		2. 根据 launcherMode 分配坑位，这里可以通过gradle脚本制定每种launcherMode 分配多少个坑位
		3. 主题是否透明来进行分配 - 2种
		4. taskAffinity 来分配 - 2组
		可以计算一下分配的坑位有上百个 ：  3 * 2 * 2 * (各种launcher模式的坑位数量之和)
		备注：坑位是指 由gradle在编译期间动态向manifest注册的一些 activity，本身没有实现类，只是起到声明的作用，目的瞒过系统对activity的校验

	插件的类因为是 PluginDexClassLoader 加载的，因为无法索引到 宿主中的框架的实用类，就如Replugin 这个类，插件的实现都是通过反射该类，获取到该类的 method。这些操作是在插件加载成功后，反射调用 Entry 类，把 PathCLassloader 传进来，从而在插件类反射，持有大量框架的实用方法，当需要的时候进行调用。
	如上所述，PluginCommImpl 、 PluginLibraryInternalProxy，插件反射持有这些类的静态方法，进行调用。 而且这是一种巧妙地方法，避免应用中存在两种 classloader加载的不同类，确保插件框架的所有具体实现类都是由 PathListClassLoader 加载的，因为 PluginDexClassLoader 并不具备加载这些类的能力

	3. 调用 Pmbase.init() 方法
	1. 这里会先判断当前进程是否是插件管理进程，这里假设应用配置了常驻进程，那么当程序初始化时，当前进程是UI进程，则调用 initForClient 方法，如果是常驻进程，则会调用 initForServer 方法
		1. 分析分支1：UI进程会调用 initForClient，  --UI进程
			1. 首先调用 PluginProcessMain.connectToHostSvc()
				1. 然后内部 调用 IBinder binder = PluginProviderStub.proxyFetchHostBinder(context); 这个调用很有意思，启动了 ProcessPitProviderPersist 这个provider，有意思的是，这个provider在manifest中声明进程是 常驻进程，也就是说这个调用，因为常驻进程还没建立，会涉及到进程的启动，也就是重新开始了 Replugin 框架的初始化，就会走进 分支2， 待分支2走完，常驻进程就完成了初始化，其 PmHostSvc 已经创建成功，就可以返回 binder 对象
				2. 获取到 binder 后，跟常驻进程进行连接监听， 如果监测到 常驻进程 服务断开，主动退出与 PluginManager 的binder连接，如果当前进程如果是插件进程，就杀死自己。因为插件进程服务挂掉了，无法为插件提供服务，这个时候插件进程的操作是不稳定的。
				3. PluginProcessMain 的 sPluginHostRemote 被赋值为 PmHostSvc 的远程代理
				4. 从 PmHostSvc 跨进程 获取到 IPluginManager 这个binder 对象，然后调用 syncRunningPlugins 方法，跨进程同步 运行的插件信息
				5. 注册该进程信息到“插件管理进程”中，由插件管理进程管理进程相关信息，调用Pmbase.attach(); 这里又跨进程调用 PmHostSvc.attachPluginProcess() ,
				这里将 当前进程的 IPluginClient （即PluginProcessPer）传给了插件管理进程，插件管理进程 为这个进程 创建 ProcessClientRecord，并存进PluginProcessMain的Map<String, ProcessClientRecord> ALL成员中， 并且用 IPluginClient 这个binder 远程监听 该进程记录的存活，如果断开，就从All中移除。这里可以很方便知道当前应用运行了哪些进程
				6. return
			2. 调用 refreshPluginsFromHostSvc，从远程进程中加载 所有插件信息 List<PluginInfo>，并用 mPlugins 保存起来

		2. 分析分支2：常驻进程会调用 initForServer  -- 常驻进程
			1. 新建了 mHostSvc:PmHostSvc 对象， 这个对象的类是 IPluginHost.Stub 的实现类，在构造函数中，又新建了 PluginManagerServer、PluginServiceServer两个对象
				1. PluginManagerServer 这个类是插件管理类，用来控制插件的安装、卸载、获取等。运行在常驻进程中。 它有个成员变量 mStub, 是一个 IPluginManagerServer.Stub 的实现。 
			2. 调用 PluginProcessMain.installHost(mHostSvc), 这个PluginProcessMain 持有一个 sPluginHost 变量，就是 mHostSvc，如果是UI进程的话，这个值为null， 里面在调用 PluginManagerProxy.connectToServer(sPluginHostLocal); 然后在里面，将 mHostSvc 的 PluginManagerServer 对象赋值给其 mRemote成员，这个时候，PluginManagerProxy 就持有了 PluginManagerServer 的binder 对象了。
			3. 调用 Builder.build()方法，开始扫描 程序的所有插件
				1. 根据 assets 目录下的 plugins-builtin.json 扫描内置插件，因为里面就是插件 json 数组，可以很方便解析出 PluginInfo
				2. 扫描 v5 插件，并不知道是什么东西
			4. 调用 refreshPluginMap(List<PluginInfo> plugins) , 将插件信息更新到 PmBase 的 mPlugins 中
			5. 再调用 PluginManagerProxy.load() 去让 PluginManager 加载插件信息。 这是一种新方案，也是未来的方案，所有插件的安装卸载更新都会交给 PluginManager去处理，这里通过一个 PlulginList 来保存插件信息，并且发生变化后，就调用save方法，将PluginInfo对象数组转成Json字符串，存进 app_p_a/p.l 文件中，方便后续恢复
				1. 打开 files 目录下的 app_p_a/p.l 文件，然后读取Json 字符串，然后把其转成 PluginInfo 数组
				2. 调用 updateAllIfNeeded 方法，检查更新，更新的逻辑如下：
					1. 插件正在运行，不需要处理
					2. 如果插件被标注为 unInstall ,那么需要将其dex、lib、jar删除、并且通知其他进程，插件信息需要删除，并且更新将其移除出PluginList
					3. 如果插件需要更新，因为前面已经判断了插件是否运行，如果能跑到这里，可以直接更新，覆盖掉原来的插件或者直接删除
				3. 如果 上面存在被更新的插件，那么需要保存一下 PluginList 到 p.l 文件
				4. 返回 List<PluginInfo>
			6. 继续调用 refreshPluginMap 方法，更新插件信息，这个时候， Pmbase 的Plugin信息就和 PluginManager 的信息保持同步了。

		3. 分支走完，就会 用mPlugins更新 PluginTable ，可以方便查询插件信息的 map对象

	4. 调用 PatchClassLoaderUtils.patch(application) hook 掉 应用的 PathListClassLoader
		1. 调用 application.getBaseContext() 获取到 Context 对象，然后通过反射，获取到 Context 的 mPackgeInfo, 然后继续反射 mPackageInfo 的 mClassLoader 对象，
		从 Application 创建流程就知道，这个 mClassLoader 就是全局的 PathListClassLoader, 应用就是利用它来加载 应用中的类，关于这点，可以从第七点印证
		2. 然后调用  RePlugin.getConfig().getCallbacks().createClassLoader(oClassLoader.getParent(), oClassLoader); 方法，获取到我们 具备hook 处理的 RePluginClassLoader
		3. 反射写进 mClassLoader 中，就完成了 hook 操作, 关于具体 hook 的细节，请查看 第六点 startActivity 的 第8小节。
		4. 并且设置 Thread.setContextClassLoader(repluginClassLoader),  防止在个别Java库用到了Thread.currentThread().getContextClassLoader()时，“用了原来的PathClassLoader”，或为空指针

5. 调用 PMF.callAttach() 方法
	1. 便利 Pmbase 里面的插件列表，给所有插件调用attach（mContext, mClassLoader, PluginCommImpl）
	2. 如果当前进程是因为插件而启动的，就加载当前插件，如何知道当前进程是哪个插件启动的呢？这涉及到插件的安装，举个例子，当activity启动的时候，该activity是要开启插件进程的，那么需要为其分配进程坑位，在常驻进程中的 StubProcessManager 会保存该插件的信息，那么在插件进程走框架初始化流程的时候，就可以查询到当前插件的名字，从而可以对其进行加载。调用 Plugin.load 方法，走 第五点 插件加载的方案

Pmbase.class.classloader == PathClassLoader 并非是 新注入的classLoader，因为该类加载的时候，还没有注入，并且注入的 ClassLoader 只负责加载某些类而已


四、 插件的安装、更新

1. 插件的安装时机是需要加载 插件中的类时，比如启动某插件的activity时，在启动activity之前，需要获取目标activity的类名、classloader等信息，所以需要该插件必须已经安装且加载，所以需要检测当前插件列表 PluginTable（该表在框架初始化时已经跟插件管理进程做了同步）是否有该插件的信息, 如果没有，就进入插件的安装流程。当然也有可能想进行覆盖安装，也会走 插件的安装流程（即更新）

最终会调用到 PM.pluginDownloaded(path), 对插件用文件形式进行加锁，再调用 PluginProcessMain.getPluginHost().pluginDownloaded(path) 跨进程进行插件的安装， 在PmHostSvc中，又会调用 PluginManagerServer.install(path) 方法, 这里进入插件安装流程：
1. 获取 path 这个路径对应的 apk 的 PackageInfo 信息， 包括mata信息、签名信息
2. 首先检测是否开启 插件签名校验，如果签名校验开启，校验白名单中设置的签名是否匹配，校验失败，安装流程失败
3.	然后从 PackageInfo 获取信息组装 一个PluginInfo，比如插件包名，如果mata信息有alias，记录别名，框架版本信息，标识 当前PluginInfo的状态为 NOT_INSTALL
4. 从插件列表中检查是否有该插件的信息， 如果有，证明是打算覆盖安装了，需要校验版本号信息是否 >= 原插件的版本号，是的话，标记当前PluginInfo的 isPendingConver 为true，如果不是，校验失败，安装返回。
5. 把 插件apk 移动或者复制到 安装路径，即插件的话是 app_p_a 目录，移动或者复制，这个可以在 HostConfig 里面配置，是否在安装过程中，删除掉 apk 文件，一般默认为删除
6. 释放apk 里面的 so 库
7. 判断该插件是否有旧版本，就是上述第4点从PluginTable中查询该插件信息。
	1. 如果没有，证明是新插件，直接将当前的 PluginInfo 插进 PluginInfoList 里面，然后调用save，保存到插件信息到p.l文件中，方便以后恢复
	2. 如果存在，代表更新插件，调用updateOrLater(oldInfo, newInfo) 方法，这里oldInfo 代表原来的插件信息，newInfo 代表要覆盖或者更新的新插件信息
		1. 如果 oldInfo 已经有 待更新的 插件信息 即 getPendingUpdate 不为 null，只需要用 newInfo 覆盖掉该字段即可，pendingUpdate 是什么意思呢？因为正在运行的插件没办法再运行时替换掉，需要重启才能 走框架初始化流程，update 掉 oldInfo，而 newInfo 是需要保存起来，等待重启才生效，就保存在 oldInfo 的 pedingUpdate 中。
		2. 如果没有pendingUpdate, 那么判断当前 插件是否处于 running 状态， 如果是 running 的话
			1. 版本如果大于oldInfo，就将 newInfo 设置到 oldInfo 的 pendingUpdate中
			2. 如果等于的话，就设置 oldInfo.pendingUpdate = null, 设置 oldInfo.pendingCover = newInfo
		如果没有 running，直接调用 updateNow，这里会直接覆盖或更新 oldInfo 的dex、so、apk等文件， 并且将 newInfo 标识已经释放
		从这里可以看到，如果是 新安装插件 或者 当前插件没有运行，会直接对 插件进行释放，而如果是等到重启后才能生效的插件，就要在运行时 释放插件的信息，有点耗时，所以 调用 Replugin.install（path）方法后，最好手动释放插件信息。
	3. 将 上述变更的信息，保存到 PluginInfoList， 然后调用 save，保存到插件信息到p.l文件中，方便以后恢复

上述已经在 插件管理进程安装完 插件了，其实就是保存好信息到 PluginInfoList 中，如果插件没安装过，或者没运行，可以提前释放，做的操作仅此而已。
然后需要将 插件管理进程中 刚安装的新的插件信息 newInfo，调用 PmHostSvc.syncInstalledPluginInfo2All(newPluginInfo)
1. 首先确定要 同步的 PluginInfo 是newInfo 还是 oldInfo，如果插件正在运行，不能更新 newInfo, 只需要更新 oldInfo 即可，因为 oldInfo的 pendingUpdate 包含 newInfo
2. 在常驻进程内更新插件内存表 ，包括 Pmbase.mPlugins 和 PluginTable
3. 调用 IPC.sendLocalBroadcast2AllSync(mContext, intent(ACTION:PmBase.ACTION_NEW_PLUGIN)) 通知其他进程更新插件列表。
	1. 如果通知其他进程进行更新？ 还记得在框架初始化的过程中，initForClient 中，会尝试将当前进程 连接到常驻进程， 常驻进程持有当前进程的 IPluginClient 对象，由这里，就可以跨进程调用 PluginProcessPer.sendIntentSync 方法，然后再各自的进程 调用 LocalBroadcast.sendBroadcast 即可

4. 关于各进程注册 PmBase.ACTION_NEW_PLUGIN action的广播时机是 application 调用 oncreate方法后， 通过 调用Replugin.onCreate 方法，然后调用 Pmbase.callAppCreate,在该方法里面就注册了该广播，注意只注册 非常驻进程的，其他的已经处理过了。该广播的会调用 Pmbase.newPluginFound 方法
这里更新逻辑跟常驻进程一样，更新插件内存表 ，包括 Pmbase.mPlugins 和 PluginTable，然后再发送 RePluginConstants.ACTION_NEW_PLUGIN 的本地广播，这里可以供进程内部的开发者监听，插件安装的结果。

至此，插件的安装完成。


五、 插件的加载

需要注意的是： 如果打开了一个 需要在插件进程运行的 activity，该插件实际的加载过程 将会涉及两次加载，第一次是在调用进程，获取到插件的信息，然后向 StubProcessManager 申请进程坑位，然后开启插件进程后，再框架初始化流程走到最后，调用 PMF.callAttach() 方法，查询进程的默认插件，即启动该进程的插件，对其进行加载，而插件的 activity 使用的资源 也应该是 插件进程的，而不是启动进程。

1. 调用了 Plugin.load(int load, boolean cache):boolean 进行插件的加载， Plugin在第四点的时候就通过 PluginInfo 构造了。
参数说明， load：有4个级别，分别是加载 PackageInfo、resource、classLoader、App(Context)
	1. 先判断插件是否禁用，禁用了直接加载失败
	2. 判断插件是否已经初始化，初始化后，直接根据 load 级别来返回。一般插件从来没有加载过的话，初始加载都是直接加载app级别的，即整个apk的信息都加载了。即这里一般跳过
	3. 如果使用缓存的话，直接用 Plugin 的静态变量缓存中读取，如果曾有过加载的话，就可能会命中，命中就返回true
	4. 对 Plugin 加锁，其实就是加多了一个文件而已。 后续步骤加载完之后就解锁
	5. 调用 Plugin对象的 doLoad 方法， 新建了一个 Loader 对象（核心类），其作为Plugin的一个成员变量，然后调用其 loadDex方法去加载apk。 
	Loader类 持有一个插件的大部分信息、包括：mPackageInfo (包含插件包名、进程名、四大组件的信息、四大组件的Intent-fliter信息)、mComponents:ComponentList（封装好插件apk的四大组件的基本信息，通过这个类可以很容易找到插件 manifest 中声明的activity 的ActviityInfo信息）、mPkgResources:Resource(插件apk的资源加载类)、
	mCladdLoader:DexClassLoader (插件的classloader)、mPkgContext：Context（其实是一个PluginContext，该类的构造函数会保存mPkgResource、mClassLoader、loader对象）

	6. loadDex方法的方法逻辑如下：
		1. 如果 mPackageInfo == null, 缓存为空，就通过 PackageManager的getPackageArchiveInfo 方法去加载 PackageInfo 信息，存进loader对象中，并且存进Plugin的静态缓存中
		2. 如果 mComponents == null, 缓存为空， 就通过 mPackageInfo 中的包信息，初始化四大组件的基本信息，不是加载，只是一些基本信息的记录、最后缓存进Plugin的静态缓存中
		3. 如果 mPkgResources == null，缓存为空， 就通过 PackageManager的 getResourcesForApplication 加载出 Resource 对象，只要能获取到 PackageInfo，安装包存在，该方法不会抛异常，最后缓存进 Plugin 静态缓存中
		4. 如果 mClassLoader == null，缓存为空， 就通过 Replugin.getConfig().getCallbacks().createPluginClassLoader 构造一个 DexClassLoader， 其中参数Parent是尚未注入 的 ClassLoader， 即普通的 PathListClassLoader。
		5. 构建 mPkgContext。

	7. 调用 PluginManager 更新插件信息
	8. 如果 load 是 loadApp 级别， 调用loader对象的loadEntryMethod2 方法，借用新构建的DexClassLoader反射 Entry类， 然后将调用Entry.create方法 mPkgContext、PathListClassLoader、PluginCommImpl 传进入，因为现在已经在插件的ClassLoader加载的class，然后进行初始化操作， 该初始化操作主要是为了初始化插件的环境变量

2. 调用 callApp 方法
	1. 调用 PluginApplicationClient 的 getOrCreate 方法，然后判断有没有缓存，没有就在里面创建了 PluginApplicationClient 对象，缓存并返回出去
	2. 在创建 PluginApplicationClient 时候，通过反射，持有了Application 类 的 构造器、attach两个方法，然后调用 newInstance 就创建了Applcation对象
	3. 通过调用 PluginApplicationClient 的 callAttachBaseContext 、callOnCreate 方法，就可以调用 application 的对应方法了。 
总结：插件的 Application 的启动很简单，单纯就反射对象的方法，并传值，并没有涉及到与系统的生命周期变化. 插件的上下文是PluginContext， 里面重载了很多 ContextWrapper 的 方法。


六、 startActivity
主要是讲这两种情况： 宿主启动插件Activity 、或者插件启动插件Activity，因为宿主启动宿主activity，插件启动宿主activity，这里直接走系统流程即可。因为宿主的activity不需要坑位，因为已经在 manifest 中声明

上述分析的两种，其 Intent 的构造都是 Intent.setComponentName("plugin","xxxactivity"); componentName的包名换成了插件名。
上述两种情况都是借助了 Replugin.startActivity来启动的， 插件因为在加载的时候，就初始化了Entry，如第五点所论述的，它持有Replugin这个类的静态方法，这样子就可以借助Replugin来启动Activity的了。

最后会调用 PluginLibraryInternalProxy.startActivity(Context,Intent intent,String plugin,String activty,int process, boolean download)

1. 首先判断 download 是否为 true，即插件是否需要加载， 默认为true， 里面会调用 PluginTable.get(plugin) ，如果不为null， 证明插件已经在加载了，如果为空，就需要判断是否要进行加载。 如果里面插件没有加载，最后会走上述第五点的流程，完成插件的加载和 application 初始化、插件框架初始化。

2. 判断 目标activity 是否是 hookingClass， 因为 hookingClass 已经 注册了，可以在 hook掉的ClassLoader 直接找到目标插件和 DexClassLoader进行加载。

3.  判断插件是否禁用，如果是禁用了，就不需要启动该插件的activity了
4. 判断插件是否已经释放，因为插件如果很大，释放会比较耗时，可以在这里回调 RePlugin.getConfig().getCallbacks().onLoadLargePluginForActivity，来提示用户插件在加载。

5. 调用 PluginCommImpl.loadPluginActivity 去寻找坑位Activity的 ComponentName
	1. 先根据 Intent，插件activity的名字 和 插件名，调用 getActivityInfo 方法，找到目标Activity
		1. 这里先通过 Pmbase.loadAppPlugin，加载到Plugin对象，然后去该 Plugin 的Loader中，Loader的componentList中查找 activityInfo
		2. 如果找不到，再通过Intent的IntentFilter去查找。 最后如果查找不到，返回null
	2. 找到activityInfo后，设置 Intent 的主题为activityInfo的主题，根据activityInfo的 processName，获取进程 process：int 值
	3. 调用 MP.startPluginProcess(plugin, process, info)，开启目标进程
		1. 该方法最后会到 插件管理进程中 调用 PmBase.startPluginProcessLocked,如果process 不是合法的，就会默认设置为 UI进程。
		2. 接着在方法内部调用 PluginProcessMain.probePluginClient(plugin, process, info)：IPluginClient  检查当前 process 指定进程是否启动，进程是否启动，其实在 第一点框架的初始化 已经做出解析，进程启动后会生成一个 ProcessClientrecord, attach进程信息到 ProcessPluginMain 的 ALL 中，ProcessClentRecord是 all的 键值类型，该类型的 client：IPluginClient 是一个跨进程Stub， 真实实现类是 PluginProcessPer
		3. 如果上述方法返回了 PluginProcessPer对象，就return，否则调用返回了 null， 这代表 目标进程 没有启动，然后调用 StubProcessManager 分配进程坑位
		4. 校验 坑位的合法性，通过后，调用 PluginProviderStub.proxyStartPluginProcess(mContext, index) 启动目标进程。
			1. 通过ContentProvider，和gradle插件 在manifest中动态注册的 ContentProvider（在manifest声明不同进程），来启动这些ContentProvider来开启坑位进程。因为在manifest中注册的ContentProvider，其process是有规律的，可以用 authority + 上述坑位的process 组合成authority，从而巧妙的开启坑位进程。
		5. 再次调用 PluginProcessMain.probePluginClient(plugin, process, info)，检测目标进程是否启动
		6. 返回PluginProcessPer：IPluginClient 对象
	4. 调用 String container = client.allocActivityContainer(plugin, process, ai.name, intent) 跨进程分配 activity 坑位， client 就是IPluginClient
		1. 根据Plugin的loader 获取到activityInfo
		2. 借助 PluginContainer 的 alloc(ActivityInfo ai, String plugin, String activity, int process, Intent intent) 方法
			1. 构建了一个 ActivityState 的空对象
			2. 判断 activityInfo 的laucherMode 和 taskAffinity 来调用不同的 allocLocked 重载方法，我们下面就只分析 singleTask、singleTop这个方法。
			3. 这里首先调用 ActivityState 的 isTarget 方法判断 plugin 和 activity 是否匹配，匹配就返回这个 ActivityState 对象，这是缓存调用，可以应付 singleTop这些重复占坑的问题。 如果没有的话，就分配一个state状态为none的坑位，返回ActivityState对象，并且将activity、plugin这些信息注入到 该 ActivityState 中。
			4. 返回 ActivityState.container：String， 这个就是activity占位坑 activity的类名，就是 gradle 动态注册的占坑activity，它不具备实现类，只是在manifest中声明而已，因为 hook掉的 RepluginClassLoader 不会加载它的
	5. 从4中获取到 container 后，就返回 要启动坑位的 ComponentName(PackageName, container)

6. 从 5 中获取到的 ComponentName, 参数 Intent 设置这个 ComponentName， 然后调用 context.startActivity(intent) 即可，这里就会走系统的调用流程

7. 从activity的启动流程来看，必然会在 scheduleLaunchActivity 的流程中， 调用应用的 classLoader 对 坑位 activity 进行加载， 而应用的classLoader 已经变成了 hook 掉的 RepluginClassLoader，可以查看其 loadClass 方法， 会将 加载 类的过程 首先代理给 Pmbase.loadClass（Sting className, boolean resolove）
	1. 其中一个语句会判断 mContainerActivities.contains(className)， 即 className 是否是 坑位 activity，哈哈，这里捉到了，
	然后调用 PluginProcessPer.resolveActivityClass(container) 方法, (container == className)
		1. 调用 PluginContainer.lookupByContainer(container), 返回 ActivityState， 这里从流程 5.3 就可以看到，这是在分配坑位的时候，保存了 plugin 和 activity到 ActivityState 中，这里又将这些信息拿出来。
		2. 调用 Pmbase.loadAppPlugin 获取到 plugin 对象，然后用 其ClassLoader 加载activity 类（classLoader 是 PluginDexClassloader），然后返回 目标activity 类，而不是坑位activity类。
最后返回目标activity类，从而实现 坑位 和 目标插件 activity 的偷梁换柱，欺骗过系统。 为什么可以欺骗系统，看 第七的分析


七、 为什么hook掉 ClassLoader 替换掉 坑位Activity，就可以启动Activity呢

可以从 Activity 启动过程分析知道， 当我们启动一个 Activity 后， AMS会校验 我们传递的 Intent，检测它对应的 Activity 是否在 Manifest 存在，当然也可能是校验 Intent-filter 有没有找到对应的 activity， 如果找到了，就调用该Activity 所在应用的 ApplicationThread 进行activity的创建， 即 scheduleLaunchActivity。
这就是为什么需要用坑位activity的原因，因为需要避过 系统的校验。
AMS校验通过后，就会跨进程呼叫 需要启动的 activity 的进程，进行创建 ActivityClientRecord， 并且传入 PackageInfo 和 ClassLoader，
在ActivityClientRecord里面，将会创建一个 token，这是一个binder 对象，是AMS唯一标识一个activity的， 然后 利用ClassLoader、 Intent传回来的activity 类名，进行类加载，实例化，并且将 token attach到新创建的activity。

上面这个过程，因为hook掉了ClassLoader，所以我们将 坑位activity对应的插件activity实例化，然后绑定 token， 这样就完成了欺骗系统的目的，因为AMS只认 token 这个标识符， 我们的插件activity也拥有这个token binder，所以能够正确接收生命周期调用



八、关于 PluginContext 和 插件 Activity 如何调用 引用插件资源

从第七节可以知道 hook 掉 activity 的原理，但是插件 activity 的 context 对象，并没有处理过，仍然是跟着系统流程，在 attachBaseContext 中绑定生命周期中构建的Context，这就会导致插件的资源无法加载。因为插件中的资源 需要 PluginContext 中的 mPkgResource 才能加载，插件中的类需要 mClassLoader这个 PluginDexClassloader 才能加载。所以如果不想办法去 替换掉 activity 中的 context 成 PluginContext，然后在 PluginContext overide 那些资源、类、启动的组件方法，从而让插件 activity 可以正在工作

比较容易想到的是，直接在 Activity 的 attachBaseContext 方法中，将系统传入的 Context 偷梁换柱成 PluginContext，而 RePlugin 正是这样做的，它提供了 各种类型的 Activity 的代理类， 比如Activity的代理类 是 PluginActivity， 建议我们编写插件 Activity 的时候，继承这个 类，这样子， PluginActivity 就可以接管 来自activity 的各种请求。 当然考虑到入侵性太强，replugin 通过 gradle 插件，动态修改字节码文件，将 所有activity 全都继承于 PluginActivity，这样实现了 PluginContext 的注入。

PluginActivity 除了注入了 PluginContext 方法，还代理了一些必要的生命周期方法，如onDestroy，为什么呢？因为 插件 activity 的生命周期回调，宿主是不知道的，需要告知宿主，比如当前 activity 已经 destroy 掉了，宿主需要将其坑位回收。关于插件 activity 是如何调用到 宿主中的类，因为 两个 ClassLoader 是不一致的，存在隔离。 这是上述 插件加载的时候提到的 Entry 类的初始化， 这是 Plugin 的初始化，会传入 宿主的 ClassLoader, 从而能够 反射 宿主的类，并且持有其 Method，从而能够调用。这样子就轻松的将 所有 Plugin 需要与 宿主交互的方法，代理出去了，而 Plugin 尽量保持简单，不做 复杂的工作，全部交由宿主去做，Plugin 只需要能够加载资源，接受生命周期回调即可，并且在适当时候，通知其生命周期的改变。毕竟 PluginManager、Pmbase、Loader、PluginContainer、PluginProcessPer 这些类全都是宿主程序管理的，插件不应该去交互。

举个 PluginContext startActivity 的例子：

PluginContext 重载了 startActivity(Intent) 方法，当 在插件内部调用 startActivity 时，就会将 处理代理到 Factory2.startActivity(this, intent)，而Factory2 其实是调用了 PluginLibraryInternalProxy.startActivity(context,intent)， 这个类就是宿主启动activity 都会经过的处理类。

这里的逻辑是：
1. 首先判断是否是用兼容模式启动，什么叫兼容模式呢？这里不是由用户指定的，当在该方法内部检测到 这个activity是 hook class，即宿主程序已经 在 manifest 中声明，就会再次调用这里的逻辑，然后使其走系统流程调用。因为不是要做额外的处理。
2. 从 Intent 中获取 需要启动的 activity 名字，如果发现是 坑位activity， 直接按照系统流程走即可
3. 获取 该 activity 的 plugin 名字
4. 获取 activity 的进程 process
4. 有了上面这些数据，就可以根据 第六点 走 startActivity 的流程了


九、启动插件 Service

1. 利用 PluginServiceClient 启动服务


十、gradle host

十一、gradle plugin

十二、 javaAssist 动态修改字节码文件