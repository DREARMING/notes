
*应用层ACK通过六大报文保证可靠传输

假设 A -> B 发送了一条信息

Msg : R   --	A -> Server
Msg : A   --	Server -> A
Msg : N   --	Server -> B

-----------------------------

ACK : R   --	B -> Server
ACK : A   --	Server -> B
ACK : N   --	Server -> A


上述机制保证了 A 知道了 B收到了消息。同时把报文的可达性转移到客户端，服务器只需要做转发工作，减轻性能负担

下面是可能发生各种情况：

MsgR 和 MsgA 没有发送出去或者没有收到，可以通过 报文 超时重传来解决。即通过一个队列记录当前发送的报文，等待服务器ACK。服务器ack后，从报文重传队列里面去掉。

加入上述 MsgR 和 MsgA 没有发生问题，那么 A收到了Ack，但是这个时候不知道 B是否收到没有，这个时候，需要push一个请求进 ACK队列里面，这个队列不是报文重传队列，同时加入Timer机制，如果超时之后，ACK还没有回来，则重新进行报文发送。如果及时回来了，就从ACK队列里面去掉。

当然，如果有可能发生这种情况，B已经收到了消息，但是回复给A的ack报文丢失了，这个时候A又重发了信息过来，这个时候，不进行界面更新即可，仍按照流程处理。因为是同一个信息，所以不用担心消息重复问题。


*上述是理想情况，如果退出了应用呢？内存保存的信息没了，如何处理，持久化？

报文重传队列的参数如何设置？超时和重传次数

ack队列的超时发送

如何去重？
服务器的自增id作为标识

TCP的方案 和 UDP的方案有啥不一样


群聊设计：




