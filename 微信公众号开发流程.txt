微信公众号开发流程：

1. 在公众号中成为开发者，填写服务器IP、密钥等信息，微信后台会发验证信息到该服务器，服务器校验微信后台的信息，并且回复，即绑定服务器成功

2. accessToken是微信接口的唯一调用凭证，每次向微信获取数据时，都需要提供这个凭据

3. 微信不同公众号能够调用的接口权限是不一样的，开发者可以用测试账号进行调试。分别有订阅号、服务号，这两种又分认证或没认

4. 微信提供的功能：
1. 自定义菜单（用户点击菜单后，微信会推送相关事件到服务器。菜单类型有多种：点击、跳转网页、返回mediaID信息，位置、图片、拍照、扫一扫等），获取自定义菜单（包括公众号设置，api设置），删除菜单

2. 接收事件推送
1. 关注和取消关注
2. 扫描带参数二维码事件
3. 上面1提到的自定义菜单事件
4. 上报位置信息事件

3. 消息管理：
1. 接收用户发送的各种类型信息，
2. 根据用户发送的消息被动回复用户各种类型消息
3. 消息加密
4. 客服消息：
	1. 创建客服账号、获取账号列表、上传头像、修改、删除客服账号
	2. 回复用户信息：发送上面的基本信息，还可以发送卡券、小程序卡片(需要与公众号绑定)
5. 模板消息，需指定行业，获取行业中的模板，填充数据回复


4. 素材管理
1.上传图片、音乐、视频、图文素材（临时、永久）
2. 获取素材列表，通过mediaID获取素材。（图文素材在公众号平台上新建后，通过api查询素材，获取到该图文素材的数据，就可以回复图文素材信息了！）

5. 用户管理
1. 建立标签、删除标签，修改标签
2. 为用户添加、删除标签、查询用户标签列表
3. 获取用户基本信息，openId对于该公众号唯一（如果公众号纳入开放平台，基本信息会有unionId，所有公众号唯一）
4. 获取用户位置信息，需要用户发送位置过来才行。

6. 账号管理
1. 生成带参数的二维码，可以在用户扫码关注时，后台会受到事件信息，通过参数知道是在哪扫描关注的


7. 网页开发
1. 提供原生WebUI进行开发，即用户体验跟微信一致的UI控件
2. JSSDk（支付、分享、图像、音频、智能接口，位置、扫一扫等）






微信公众号和小程序支付步骤：
1. 开公众号或小程序后台开通微信支付，微信官方审核几天后会给你发送邮件
2. 从邮件中获取商户平台登陆账号、商户平台密码，商户号。
3. 去微信商户平台登陆，在安全设置页面找到app key，该key由客户后台向微信后台发起请求需要。
4. 安全设置页面的证书是本地安装的，用于在pc上查询订单、退款等操作。




微信公众号内的h5页面支付：
1. 首先h5里面生成订单信息，交给后台。
2. 后台发起统一订单api，向微信后台下单，微信后台返回prepayId给后台
3. 后台翻回prepayId给前端js，js调用 getBrandWCPayRequest 给微信后台。
4. 微信后台校验后，调起微信客户端的支付界面。
5. 完成支付后，微信后台会给js一个回调，同时也会给客户后台一个信息。但这两个信息是异步的。
6. js收到回调后，给用户一个支付反馈，最好先向客户后台查询订单的支付状况，如果客户后台的订单支付状况还没返回，可以调用查询订单api，再返回给js
7. js显示支付结果。


小程序学习：
1. 小程序通过json文件配置对象，比如Page、App、自定义组件的配置；用js定义脚本和方法；用wxml定义外观；用wxss定义样式
2. App对象，是全局数据集、小程序启动生命周期监听的定义地方:onLaunch、onShow、onHide、onError、onPageNotFound
3. Page对象，注册一个页面，是页面数据集，方法集，属性集，生命周期回调的地方，onLoad、onShow、onReady、onHide、onUnload
4. 模块的定义。wxs文件和<wxs>标签块都是具有自己的作用域，外界无法访问，通过内置对象module的exports属性给外界暴露方法。
	require函数用来在wms文件中引用其他wxs
5. 模板函数
6. 


Flex布局

容器属性

1. flex-direction : row、row-reverse、column、column-reverse
设置Flex布局的主轴方向、默认是横向，该方向决定容器内部的项目的排列方向。

2. flex-wrap: nowrap(default)、wrap、wrap-reverse
设置容器是否包裹住全部内容，默认不包裹，超出部分将会溢出,如果包裹的话，将会换行

3. justify-content
设置项目在主轴方向上对齐方式，以及分配项目之间及其周围多余的空间。
flex-start
flex-end
flex-center		所有项目集中在主轴中间
space-between
space-around
space-evenly	项目之间的间隔相等，评分整个容器的主轴方向的位置

4. align-items	
设置项目在行中的对齐方式。

stretch（默认值）：项目拉伸至填满行高。
flex-start：项目顶部与行起点对齐。
center：项目在行中居中对齐。
flex-end：项目底部与行终点对齐。
baseline：项目与行的基线对齐。

5. align-content
多行排列时，设置行在交叉轴方向上的对齐方式，以及分配行之间及其周围多余的空间。

stretch（默认值）：当未设置项目尺寸，将各行中的项目拉伸至填满交叉轴。当设置了项目尺寸，项目尺寸不变，项目行拉伸至填满交叉轴。

flex-start：首行在交叉轴起点开始排列，行间不留间距。

center：行在交叉轴中点排列，行间不留间距，首行离交叉轴起点和尾行离交叉轴终点距离相等。

flex-end：尾行在交叉轴终点开始排列，行间不留间距。
space-between：行与行间距相等，首行离交叉轴起点和尾行离交叉轴终点距离为0。
space-around：行与行间距相等，首行离交叉轴起点和尾行离交叉轴终点距离为行与行间间距的一半。

space-evenly：行间间距、以及首行离交叉轴起点和尾行离交叉轴终点距离相等。



项目属性

1. order
设置项目沿主轴方向上的排列顺序，数值越小，排列越靠前。属性值为整数。

2. flex-shrink
当项目在主轴方向上溢出时，通过设置项目收缩因子来压缩项目适应容器。属性值为项目的收缩因子，属性值取非负数。

2. flex-grow
当项目在主轴方向上还有剩余空间时，通过设置项目扩张因子进行剩余空间的分配。属性值为项目的扩张因子，属性值取非负数。

4.flex-basis 属性

当容器设置flex-direction为row或row-reverse时，flex-basis和width同时存在，flex-basis优先级高于width，也就是此时flex-basis代替项目的width属性。

当容器设置flex-direction为column或column-reverse时，flex-basis和height同时存在，flex-basis优先级高于height，也就是此时flex-basis代替项目的height属性。

需要注意的是，当flex-basis和width（或height），其中一个属性值为auto时，非auto的优先级更高。

5. flex 属性

是flex-grow，flex-shrink，flex-basis的简写方式。值设置为none，等价于00 auto。值设置为auto，等价于1 1 auto。

6.align-self 属性

设置项目在行中交叉轴方向上的对齐方式，用于覆盖容器的align-items，这么做可以对项目的对齐方式做特殊处理。默认属性值为auto，继承容器的align-items值，当容器没有设置align-items时，属性值为stretch。



自定义组件基本要素：
1. 组件界面和样式设置


2. 构造函数与初始化

3. 属性集合、数据集（属性用于组件内部，数据集是要暴露给外部的，用于更新UI）
1. 组件内部提供自定义属性
2. 组件采用数据驱动原理，数据集一旦发生变化，会导致组件内部发生渲染，从而影响组件变化

4. 事件以及事件的传递
1. 事件的捕获与冒泡控制了事件的传递，比如滑动冲突的处理。bind事件不会影响事件的冒泡和捕获。capture-bind会影响
2. 在组件内部定义方法，让组件内部的子组件触发方法，控制数据集变化，从而影响组件的变化
3. 触发自定义事件

5. 继承与组合

6. 生命周期
1. onCreate
2. onAttach
3. onUnAttach


8. 组件方法